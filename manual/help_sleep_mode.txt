
//////////////// РЕЖИМЫ ЭНЕРГОСБЕРЕЖЕНИЯ ARDUINO //////////////////////

Если вы запускаете свой проект от источника питания 12 В, то он потребляет более 50 мА тока. 
Понизив напряжение до 9-вольтовой батареи, вы можете уменьшить потребляемый ток примерно до 33 мА.
Но вы можете внести изменения в оборудование, чтобы уменьшить потребление тока.
Питание подключенных устройств через порт ввода-вывода (I/O, Input/Output) позволяет выключать устройство, когда оно не используется.



Библиотеки для управления спящим режимом:
1. стандартная avr/sleep.h, которая идёт в комплекте со средой разработки.
    подключение - #include <avr/sleep.h>

    Чтобы произвольно установить значение спящего режима надо вызвать set_sleep_mode(mode), а затем вызывается sleep_mode(). 
    Если не стоит цель блокировать CPU аппаратно (до аппаратного сброса), прерывания в этом пункте нужно разрешить. 


void set_sleep_mode(uint8_t mode) - Выбор спящего режима.
Устанавливает разряды регистра MCUCR для выбора "спящего"режима. Возможные значения для mode:
    SLEEP_MODE_ADC - режима пониженногоаа шумаа от АЦП;
    SLEEP_MODE_EXT_STANDBY - расширенныйа режим ожидания;
    SLEEP_MODE_IDLE - ждущий режим;
    SLEEP_MODE_PWR_DOWN - режим пониженного энергонпотребления; (самый экономный режим)
    SLEEP_MODE_PWR_SAVE - режим энергосбережения;
    SLEEP_MODE_STANDBY - режим ожидания.

void sleep_cpu() - Переводит МК в спящий режим . Бит SE должен быть установлен заранее, и рекомендуется впоследствии сбросить его.
void sleep_disable() - Сбрасывает бит SE (запрещение спящего режима).
void sleep_enable() - Устанавливает бит SE (разрешение спящего режима).
void sleep_mode() - Переводит МК в "спящий" режим. Выход устройства из этого режима зависит от установки, вынполненной с помощью функции set_sleep_mode.

Пробуждение по сторожевому таймеру:
В основе сторожевого таймера (WatchDog Timer) лежит многоразрядный счетчик, снабженный собственным тактовым генератором. 
Если таймер включен, то значение счетчика будет постоянно увеличиваться и при его переполнении будет сгенерирован сигнал сброса МК. 
Чтобы избежать сброса по переполнению программа должна постоянно обнулять счетчик специальной командой. 
Если программа зависла и счетчик не был вовремя сброшен, то сигнал сброса выведет МК из зависшего состояния, таким образом повышается стабильность системы на основе МК.
#include <avr/wdt.h> - подключение библиотеки для работы с WatchDog

//Пример засыпания и просыпания по сигналу сторожевого таймера.
//Ардуино будет просыпаться каждые 2 секунды и мигать встроенным светодиодом для индикации пробуждения.
void loop() 
{
  wdt_enable(WDTO_2S); //Задаем интервал сторожевого таймера (2с)
  WDTCSR |= (1 << WDIE); //Устанавливаем бит WDIE регистра WDTCSR для разрешения прерываний от сторожевого таймера
  set_sleep_mode(SLEEP_MODE_PWR_DOWN); //Устанавливаем интересующий нас режим
  sleep_mode(); // Переводим МК в спящий режим, здесь программа как бы замирает, далее через 2с выполнится ISR (WDT_vect), а после этого основная программа продолжит выполнение
  digitalWrite(LED_BUILTIN, f);
}
ISR (WDT_vect) //выполняется при генерации прерывания от сторожевого таймера
{
  wdt_disable();
  f = !f;
}


Пробуждение микроконтроллера при замыкании/размыкании контактов:
Это пробуждение по внешнему прерыванию (INT) или по прерыванию изменения уровня (PCINT). 


2. LowPower.h

    
3.  GyverPower

    подключение -#include "GyverPower.h"

    power.setSleepMode(mode); // задает режим сна, см константы в GyverPower.h (по умолчанию POWERDOWN_SLEEP)
	IDLE_SLEEP       Легкий сон, отключается только клок CPU и Flash, просыпается от любых прерываний
	ADC_SLEEP      	 Легкий сон, отключается CPU и system clock, АЦП начинает преобразование при уходе в сон (см. пример ADCinSleep)  
	POWERDOWN_SLEEP  Наиболее глубокий сон, отключается всё кроме WDT и внешних прерываний, просыпается от аппаратных (обычных + PCINT) или WDT за 1000 тактов (62 мкс)
	STANDBY_SLEEP    Глубокий сон, идентичен POWERDOWN_SLEEP + system clock активен, пробуждение за 6 тактов (0.4 мкс)
	POWERSAVE_SLEEP  Глубокий сон, идентичен POWERDOWN_SLEEP + timer 2 активен (+ можно проснуться от его прерываний), можно использовать для счета времени (см. пример powersaveMillis)
	EXTSTANDBY_SLEEP Глубокий сон, идентичен POWERSAVE_SLEEP + system clock активен, пробуждение за 6 тактов (0.4 мкс)

    //включение спящего режима на заданное время
    power.sleepDelay(5000); // спим 5 секунд (5000 мс), после чего МК просыпается и продолжает выполнять программу с этого места   

    //включение спящего режима на неопределенный срок
    power.sleep(SLEEP_FOREVER)


пример(просыпаемся по кнопке):
void setup() 
{
  Serial.begin(9600);
  pinMode(3, INPUT_PULLUP); // кнопка подключена к GND и D3
  attachInterrupt(1, isr, FALLING); // подключаем прерывание на пин D3 (Arduino NANO)
  power.setSleepMode(POWERDOWN_SLEEP); // задание режима глубокий сон
}
void isr() { to do } // обработчик аппаратного прерывания
void loop() 
{
  Serial.println("go sleep");
  delay(300);
  power.sleep(SLEEP_8192MS); // спим ~8 секунд, но можем проснуться по кнопке
  Serial.println("wake up!"); // тут проснулись, по кнопке или через указанный период
  delay(300);
}


