РАБОТА С ПРЕРЫВАНИЯМИ в ардуино

//Аппаратные прерывания
Прерывание в Ардуино можно описать так: микроконтроллер “всё бросает”, переключается на выполнение блока функций в обработчике прерывания, 
выполняет их, а затем возвращается к тому месту основного кода, в котором остановился.

  External hardware interrupt – это прерывание, вызванное изменением напряжения на пине микроконтроллера. 
    Сейчас нужно понять, что аппаратные прерывания могут генерировать только определённые пины: для Nano, UNO это: D2(INT 0), D3(INT 1)
    Как вы поняли из таблицы, прерывания имеют свой номер, который отличается от номера пина.

  digitalPinToInterrupt(pin); //возвращает номер прерывания по номеру пина, для того чтобы не задумываться к какому пину какое прерывание относится

Подключается прерывание при помощи функции attachInterrupt(pin, func_name, mode), вызывается в setup
    pin – номер прерывания
    func_name – имя функции-обработчика прерывания (её нужно создать самому)
    mode  – “режим” срабатывания прерывания:
        LOW – срабатывает при сигнале LOW на пине
        RISING – срабатывает при изменении сигнала на пине с LOW на HIGH
        FALLING – срабатывает при изменении сигнала на пине с HIGH на LOW 
        CHANGE – срабатывает при изменении сигнала (с LOW на HIGH и наоборот)

    detachInterrupt(pin) //отключение прерывания, если оно больше не требуется где pin – опять же номер прерывания.

пример:
void setup() 
{
  // кнопка подключена к GND и D3
  pinMode(3, INPUT_PULLUP);

  // подключаем прерывание на пин D3 (Arduino NANO)
  attachInterrupt(1, isr, FALLING);
}
// обработчик аппаратного прерывания
void isr() 
{
    //здесь выполнить код, при наступлении прерывания
}


///////////////////////////////////////////////////////////////////////////////
////////////////////////////прерывания по таймеру/////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//Библиотека GyverTimers позволяет генерировать прерывания по таймеру с заданной частотой на выбранном канале таймера.

В стандартных платах Arduino на 8 битном AVR чипе имеется сразу несколько таймеров.
Atmega168 и Atmega328 есть три таймера Timer0(8 бит), Timer1(16 бит) и Timer2(8 бит). Они также имеют сторожевой таймер.
В библиотеке таймеры описаны как объекты, обращение происходит так: Timer1.stop();

Аппаратный таймер, он же счётчик, занимается очень простой задачей: считает “тики” тактового генератора (который задаёт частоту работы всей системы).
Таким образом “разрешение” работы таймера – один тик (такт) задающего генератора, при 16 МГц это 0.0625 микросекунды. 
Второй важный момент для понимания: таймер-счётчик работает и считает импульсы параллельно вычислительному ядру.

Что касается счета времени: функции millis() и micros() как раз таки работают на прерывании Timer0. 
Библиотека GyverTimers позволяет генерировать прерывания по таймеру с заданной частотой на выбранном канале таймера или на нескольких каналах сразу.

    Настройка частоты/периода
    setPeriod(период)   – установка периода в микросекундах и запуск таймера. Возвращает реальный период в мкс (точность ограничена разрешением таймера).
	для 16 МГц тактирования максимальный период считается по формуле, где F_CPU – системная частота в Гц: 
	8 бит таймеры: (1000000UL / F_CPU) * (1024 * 256)
	16 бит таймеры: (1000000UL / F_CPU) * (1024 * 65536)
    setFrequency(частота); – установка частоты в Герцах и запуск таймера. Возвращает реальную частоту в Гц (точность ограничена разрешением таймера).
    setFrequencyFloat(частота float); – установка частоты в Герцах и запуск таймера, разрешены десятичные дроби. Возвращает реальную частоту (точность ограничена разрешением таймера).

	//работа с таймером
    pause(); – приостановить счёт таймера, не сбрасывая счётчик
    resume(); – продолжить счёт после паузы
    stop(); – остановить счёт и сбросить счётчик
    restart(); – перезапустить таймер (сбросить счётчик)
	
	//подключение прерывания
    enableISR(канал, фаза); – запустить прерывания на выбранном канале с выбранным сдвигом фазы. Если ничего не указывать, будет выбран CHANNEL_A и фаза 0
        Канал CHANNEL_A: Timer0 -> D6, Timer1 -> D9, Timer2 -> D11
        Канал CHANNEL_B: Timer0 -> D5, Timer1 -> D10, Timer2 -> D3
    disableISR(канал); – отключить прерывания на выбранном канале. Если ничего не указывать, будет выбран канал A


Библиотека даёт прямой доступ к прерыванию без “Ардуиновских” attachInterrupt. 
Прерывание с настроенной частотой будет обрабатываться в блоке вида ISR(канал) {}
пример:
ISR(TIMER1_A) {// ваш код }
ISR(TIMER0_B) {// ваш код }

пример кода с генерацией прерываний аппаратным таймером:
#include "GyverTimers.h"
void setup() 
{
  Timer1.setFrequency(3);               // Высокоточный таймер 1 для первого прерывания, частота - 3 Герца
  //Timer1.setPeriod(333333);           // то же самое! Частота 3 Гц это период 333 333 микросекунд
  //Timer1.setFrequencyFloat(4.22);     // Если нужна дробная частота в Гц  
  Timer1.enableISR();                   // Запускаем прерывание (по умолч. канал А)

  // запустим второй таймер
  Timer2.setPeriod(1000000);     // Устанавливаем период таймера 1000000 мкс -> 1 гц
  Timer2.enableISR(CHANNEL_A);   // Или просто .enableISR(), запускаем прерывание на канале А таймера 2

  pinMode(13, OUTPUT);           // будем мигать
}
void loop() {} //тот случай когда в лупе ничего нет :-))) 
// Прерывание А таймера 1
ISR(TIMER1_A) { //to do } 
// Прерывание А таймера 2
ISR(TIMER2_A) 
{  
     // генерируем меандр 1 кгц, мигаем
    digitalWrite(13, !digitalRead(13));
}




