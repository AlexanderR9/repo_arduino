
// Подключение библиотек для работы с разными модулями.
//Предварительно необходимо поместить библиотеку в соответствующую папку где установлена Arduino IDE (example: C:\MyPath\Arduino\libraries\)
//под библиотекой здесь понимается файл *.h (или пара .h/.cpp), далее в скетче подключается как обычно в c++
#include <filename1.h>  
#include <filename2.h>  
.....................


//работа с последовательным портом
Serial.begin(9600); //открытие COM порта для обмена
    Serial.begin(115200); //обычно ипользуется при работе с модулями на базе ESP8266
Serial.end(); //закрыть канал обмена
Serial.available(); //Возвращает количество байт, хранящихся в буфере доступных для чтения (объём буфера 64 байта)
Serial.availableForWrite(); //Возвращает количество байт, которые можно записать в буфер последовательного порта, не блокируя при этом функцию записи.
Serial.write(val); //Отправляет в порт val численное значение или строку
Serial.write(buf, len); //отправляет количество len байт из буфера buf
Serial.print(val), Serial.print(val, format) //Отправляет в порт, В отличие от write выводит именно символы, т.е. отправив 88 вы получите 88
Serial.print(78);        // выведет 78
Serial.print(1.23456);   // 1.23 (по умолч. 2 знака)
Serial.print('N');       // выведет N
Serial.print("Hello world."); // Hello world.
Serial.print(78, BIN);    // вывод "1001110"
Serial.print(78, OCT);    // вывод "116"
Serial.print(78, DEC);    // вывод "78"
Serial.print(78, HEX);    // вывод "4E"
Serial.print(1.23456, 0); // вывод "1"
Serial.print(1.23456, 2); // вывод "1.23"
Serial.println(val); //аналог print(), но автоматически переводит строку после вывода, можно вызывать без аргументов 
Serial.read(); //Читает и возвращает байт как код символа из таблицы ASCII. Если нужно вернуть цифру, делаем Serial.read() – ‘0’;
Serial.readBytes(buffer, length); //Читает данные из порта и закидывает их в буфер buffer (массив char [] или byte []), также указывается количество байт, который нужно записать – length (чтобы не переполнить буфер)
Serial.readString(); //Читает буфер порта и формирует из данных строку String, которую возвращает. Заканчивает работу по таймауту


//time functions
delay(2000); // Приостанавливает нить на 2с. (по возможности надо стараться не пользоваться данной функцией)
millis() - Возвращает количество миллисекунд с момента начала выполнения текущей программы на Arduino, т.е. с момента старта/рестарта,
		это значение сбрасывается на ноль придостижении максимума (приблизительно через 50 дней).
//пример:
unsigned long t; 
t = millis(); 
Serial.println(t); //вывод в COM порт
if (millis()%1000 == 0) // если прошла 1 секунда
{
    //to do                                 
}


//типы данных:
bool (1 байт)
int8_t, uint8_t (1 байт) 
int, int16_t, short, uint16_t, word (2 байта) 
int32_t, uint32_t (4 байта) 
float (4 байта) 
int64_t, uint64_t (8 байт) 

массив:
int myArray[] = {3, 4, 5 ,6};
int myInts[6];

строки:
String string0 = "Hello String";
String string1 = String("lol ") + String("kek"); 
String string5 = String(13);// конвертируем из числа в String
String string7 = String(45, HEX); // конвертируем из числа с указанием базиса (16-ричный)
textString.length(); //длина строки
const char* password = "0123456"; //набор символов

//случайные числа
random(max); // возвращает псевдослучайное число в диапазоне от 0 до (max – 1), тип max unsigned long.
random(min, max); // возвращает псевдослучайное число в диапазоне от min до (max – 1).
randomSeed(value); //сброс генератора, например при запуске вызвать randomSeed(millis())

//Структуры
struct MyStruct
{
  bool button;
  bool state;
  int16_t position;
};

//defines, обьявление defines как обычно
#define NORMAL 0
#define WAITING 1

//множества enum, обьявление как обычно
enum EnumName{имя1, имя2, имя3, имя4, имя5};









